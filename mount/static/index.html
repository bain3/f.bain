<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Download</title>
    <style>
        body {
            background-color: #13131b;
            font-family: 'Nunito Sans', sans-serif;
            color: #7f7f7f;
        }

        .center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-50%);
            margin: auto;
            text-align: center;
        }
        .progress {
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.1);
            justify-content: flex-start;
            border-radius: 100px;
            align-items: center;
            position: relative;
            padding: 0 5px;
            display: flex;
            height: 1em;
            width: 300px;
        }

        .progress-value {
            transition: width ease-in-out 100ms;
            box-shadow: 0 10px 40px -10px #fff;
            border-radius: 100px;
            background: #fff;
            height: 0.5em;
            width: 0;
        }
        @keyframes slidein {
            0% {top:-20px;}
            15% {top: 7px;}
            85% {top: 7px;}
            100% {top:-25px;}
        }
    </style>
</head>
<body onload="ol()">
<div class="center">
    <p>File is being downloaded and decrypted...</p>
    <div class="progress">
        <div class="progress-value"></div>
    </div>
    <p id="errors" style="color: #ff0000;" hidden/>
</div>
<script>
    async function ol() {
        let url = new URL(location.href);
        let id_pair = [url.pathname.substring(url.pathname.lastIndexOf('/')+1), url.hash.substring(1)];
        let error_el = document.getElementById("errors");
        let progress_el = document.getElementsByClassName('progress')[0];

        if (id_pair.length === 1 || id_pair[1] === "") {
            error_el.innerText = "Link isn't correct. Could not find decryption key.";
            error_el.hidden = false;
            progress_el.style.visibility = 'hidden';
            return;
        }
        // -- request meta --
        let xhr = new XMLHttpRequest();
        let meta;
        let promise = new Promise(resolve => { // fuck callbacks
            xhr.addEventListener("readystatechange", function () {
                if (this.readyState === this.DONE) {
                    if (this.status === 200) {
                        meta = JSON.parse(this.responseText);
                    } else {
                        error_el.innerText = "Failed to download metadata. (status code:" + this.status + ")";
                        error_el.hidden = false;
                    }
                    resolve(true);
                }
            });
            xhr.open("GET", "/" + id_pair[0] + "/meta");
            xhr.send();
        });
        await promise;
        if (!error_el.hidden) return;
        document.getElementsByClassName('progress-value')[0].style.width = '5%';

        // -- getting raw encrypted data --
        let raw;
        xhr = new XMLHttpRequest();
        promise = new Promise(resolve => { // fuck callbacks
            xhr.addEventListener("readystatechange", function () {
                if (this.readyState === this.DONE) {
                    if (this.status === 200) {
                        raw = this.response;
                    } else {
                        error_el.innerText = "Failed to download encrypted file. (status code:" + this.status + ")";
                        error_el.hidden = false;
                    }
                    resolve(true);
                }
            });
            xhr.addEventListener("progress", function (p) {
                document.getElementsByClassName('progress-value')[0].style.width = 5+p.loaded/p.total*45+'%';
            })
            xhr.open("GET", "/" + id_pair[0] + "/raw");
            xhr.responseType = "blob";
            xhr.send();
        });
        await promise;
        if (!error_el.hidden) return;
        let cryptoObj = window.crypto || window.msCrypto; // for IE 11
        let crypto = cryptoObj.subtle;
        document.getElementsByClassName('progress-value')[0].style.width = '50%';

        // -- decryption --
        let te = new TextEncoder();
        let password = decodeURI(id_pair[1]);

        // derive key and ivs
        let wc_password = await crypto.importKey(
            "raw",
            te.encode(password),
            "PBKDF2",
            false,
            ["deriveBits"]
        );
        let strengthened = await crypto.deriveBits(
            {name: "PBKDF2", hash: "SHA-256", salt: new Uint8Array(meta.salt), iterations: 50000},
            wc_password,
            768
        );
        let wc_key = await crypto.importKey(
            "raw",
            strengthened.slice(0,32),
            "AES-GCM",
            false,
            ["decrypt"]
        );
        let iv = strengthened.slice(32, 64); // setting iv (second 256 bits)

        // -- decrypt filename --
        let b64 = atob(meta.filename);
        let len = b64.length;
        let bytes = new Uint8Array( len );
        for (let i = 0; i < len; i++)        {
            bytes[i] = b64.charCodeAt(i);
        }
        let filename;
        try {
            filename = new TextDecoder().decode(await crypto.decrypt(
                {name: "AES-GCM", iv: strengthened.slice(64, 96), tagLength: 128},
                wc_key, bytes
            ));
        } catch (e) {
            error_el.innerText = "Error while decrypting file, this can be caused by an invalid decryption key.\n" + e;
            error_el.hidden = false;
            progress_el.style.visibility = 'hidden';
            return;
        }

        // -- decrypt file contents --
        let output_blob = new Blob([]); // working with blobs to not crash the browser with big files
        try {
            let offset = 0;
            while (offset < raw.size) {
                // getting data
                let block = await raw.slice(offset, offset+5242928).arrayBuffer();

                // decrypting
                let d_block = await crypto.decrypt(
                    {"name": "AES-GCM", "iv": iv, "tagLength": 128},
                    wc_key, block);
                // let decrypt = sjcl.mode.gcm.decrypt(prp, sjcl.codec.arrayBuffer.toBits(block), iv);
                // let d_block = sjcl.codec.arrayBuffer.fromBits(decrypt, false);

                output_blob = new Blob([output_blob, d_block.slice(32, d_block.byteLength)]);

                // setting next iv
                iv = new Uint8Array(d_block.slice(0, 32));

                offset += 5242928;
                document.getElementsByClassName('progress-value')[0].style.width = 50+offset/raw.size*50+'%';
            }
        } catch (e) {
            error_el.innerText = "Error while decrypting file, this can be caused by an invalid decryption key.\n" + e;
            error_el.hidden = false;
            progress_el.style.visibility = 'hidden';
        }

        if (output_blob.size === 0) return;

        document.getElementsByClassName('progress-value')[0].style.width = '100%';

        // creating download for the plaintext
        const link = document.createElement('a');
        link.href = URL.createObjectURL(output_blob);
        link.download = filename;
        document.body.append(link);
        link.click();
        link.remove();
        setTimeout(() => URL.revokeObjectURL(link.href), 7000);
    }
</script>
</body>
</html>